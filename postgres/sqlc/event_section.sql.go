// Code generated by sqlc. DO NOT EDIT.
// source: event_section.sql

package db

import (
	"context"
	"database/sql"
)

const createEventSection = `-- name: CreateEventSection :one
INSERT INTO event_sections (
  event_id,
  section_id,
  presenter,
  complete
) VALUES (
  $1, $2, $3, $4
) RETURNING id, event_id, section_id, presenter, complete
`

type CreateEventSectionParams struct {
	EventID   sql.NullInt32 `json:"event_id"`
	SectionID sql.NullInt32 `json:"section_id"`
	Presenter sql.NullInt32 `json:"presenter"`
	Complete  sql.NullBool  `json:"complete"`
}

func (q *Queries) CreateEventSection(ctx context.Context, arg CreateEventSectionParams) (EventSection, error) {
	row := q.queryRow(ctx, q.createEventSectionStmt, createEventSection,
		arg.EventID,
		arg.SectionID,
		arg.Presenter,
		arg.Complete,
	)
	var i EventSection
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.SectionID,
		&i.Presenter,
		&i.Complete,
	)
	return i, err
}

const deleteEventSection = `-- name: DeleteEventSection :exec
DELETE FROM event_sections
WHERE id = $1
`

func (q *Queries) DeleteEventSection(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteEventSectionStmt, deleteEventSection, id)
	return err
}

const getEventSection = `-- name: GetEventSection :one
SELECT id, event_id, section_id, presenter, complete FROM event_sections
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEventSection(ctx context.Context, id int32) (EventSection, error) {
	row := q.queryRow(ctx, q.getEventSectionStmt, getEventSection, id)
	var i EventSection
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.SectionID,
		&i.Presenter,
		&i.Complete,
	)
	return i, err
}

const getEventSectionsByEvent = `-- name: GetEventSectionsByEvent :many
SELECT id, event_id, section_id, presenter, complete FROM event_sections
WHERE event_id = $1
`

func (q *Queries) GetEventSectionsByEvent(ctx context.Context, eventID sql.NullInt32) ([]EventSection, error) {
	rows, err := q.query(ctx, q.getEventSectionsByEventStmt, getEventSectionsByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventSection{}
	for rows.Next() {
		var i EventSection
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.SectionID,
			&i.Presenter,
			&i.Complete,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventSection = `-- name: UpdateEventSection :one
UPDATE event_sections
SET 
  event_id = $2,
  section_id = $3,
  presenter = $4,
  complete = $5
WHERE id = $1
RETURNING id, event_id, section_id, presenter, complete
`

type UpdateEventSectionParams struct {
	ID        int32         `json:"id"`
	EventID   sql.NullInt32 `json:"event_id"`
	SectionID sql.NullInt32 `json:"section_id"`
	Presenter sql.NullInt32 `json:"presenter"`
	Complete  sql.NullBool  `json:"complete"`
}

func (q *Queries) UpdateEventSection(ctx context.Context, arg UpdateEventSectionParams) (EventSection, error) {
	row := q.queryRow(ctx, q.updateEventSectionStmt, updateEventSection,
		arg.ID,
		arg.EventID,
		arg.SectionID,
		arg.Presenter,
		arg.Complete,
	)
	var i EventSection
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.SectionID,
		&i.Presenter,
		&i.Complete,
	)
	return i, err
}
